Install Fn and OCI environment
==============================

In this step, we will together prepare the environment for working with Fn.
The Katacoda scenario environment runs Ubuntu and contains Docker. We need to add Fn CLI and Fn Server.

Wait for the Fn Server to be running
====================================

In the background we are currently preparing your Fn environment.
Several Docker images are pulled and the Fn server is started.
You can check if Fn Server is running by checking the currently running Docker containers using the following command:

-----------
$ docker ps
-----------

Do not continue until you see a Docker container running based on image fnproject/fnserver:latest Fn Server is running

Get going with Fn
=================

Check the installed version - client and server - of Fn

------------
$ fn version
------------

List the currently available Fn contexts

------------------
$ fn list contexts
------------------

Notice we have a default context which deploys to a local Fn server.
The default context is created the first time you run the Fn CLI.
However, we need to select default as our current context and set a registry value for remote or local Docker use.

Set context to default - this is a local context that uses the locally running Fn server for deploying functions.

------------------------
$ fn use context default
------------------------

Before we start using Fn, we need to configure Fn to point to an appropriate Docker registry
so it knows where to push your function images to.
Normally Fn points to your Docker Hub account by specifying your Docker Hub username.
However, for pure local development we can simply configure Fn with an arbitrary value

So now update the registry setting for the default content to something meaningless.

--------------------------------------------------
$ fn update context registry something-meaningless
--------------------------------------------------

You can list the currently available Fn contexts again and see whether your changes had an effect (of course they did)

------------------
$ fn list contexts
------------------

Creating a Function with Fn
===========================

In this step we will create a simple function with Fn. We pick Node (JS) as our runtime 
- Go, Python, Java and Ruby are other out of the box options.

------------------------------
$ fn init --runtime node hello
$ cd hello
------------------------------

Three files have been created in the new directory hello.

The fn init command generated a func.yaml function configuration file.
This file provides instructions to the Fn Server to build, deploy and invoke the function.
Let's look at the contents:

---------------
$ cat func.yaml
---------------

The generated func.yaml file contains metadata about your function and declares a number of properties including:

    schema_version--identifies the version of the schema for this function file. 
                    Essentially, it determines which fields are present in func.yaml.
    name--the name of the function. Matches the directory name.
    version--automatically starting at 0.0.1.
    runtime--the name of the runtime/language which was set based on the value set in --runtime.
    entrypoint--the name of the Docker execution command to invoke when your function is called,
                in this case node func.js.

There are other user specifiable properties that can be defined in the yaml file for a function. 
We do not need those for this simple example.

The package.json file is present in (most) Node applications: 
it specifies all the NPM dependencies for your Node function on third party libraries and also on the Fn FDK for Node 
(@fnproject/fdk).

------------------
$ cat package.json
------------------

You could open func.js in the text editor to see the generated functionality of the function:
that is where the real action takes place when the function is invoked.

Deploy and Invoke the Function
==============================

Create an Fn application - a container for multiple related functions:

-------------------------
$ fn create app hello-app
-------------------------

Deploy the Function Hello locally, into the app that was just created

--------------------------------------
$ fn -v deploy --app hello-app --local
--------------------------------------

When you deploy a function like this, Fn is dynamically generating a Dockerfile for your function
building a container, and then loading that container for execution when the function is invoked.

Note: Fn is actually using two images. The first contains the necessary build tools and produces the runtime artefact.
The second image packages all dependencies and any necessary language runtime components.
Using this strategy, the final function image size can be kept as small as possible.

When using fn deploy --local, fn server builds and packages your function into a container image 
which resides on your local machine.
You can now verify that a Docker Container Image has been built for Fn Function Hello:

----------------------------
$ docker images | grep hello
----------------------------

Using the following command, you can check the Fn applications (or function clusters) in your current context:

--------------
$ fn list apps
--------------

With the next command, you can check which functions have been deployed into a specific application:

-----------------------------
$ fn list functions hello-app
-----------------------------

Time now to invoke the function. The command for invoking the function is simply: fn invoke <app-name> <function-name>:

---------------------------
$ fn invoke hello-app hello
---------------------------

To send in a JSON object as input to the function, use the following command:

------------------------------------------------------------------------------------------------
$ echo -n '{"name":"Your Own Name"}' | fn invoke hello-app hello --content-type application/json
------------------------------------------------------------------------------------------------

Again, a friendly, this time personalized, welcome message should be your reward.

What is happening here: when you invoke "hello-app hello" the Fn server looked up the "hello-app" application
and then looked for the Docker container image bound to the "hello" function, started the container
(if it was not already running) and send the request to the handler listening inside the container.

Invoke Function with CURL
=========================

In this step we will invoke the function with CURL.
Subsequently, we will take a look at the context data available to the function when it is handling a request.

Getting a Function's Invoke Endpoint
====================================

In addition to using the Fn invoke command, we can call a function by using a URL.
To do this, we must get the function's invoke endpoint.
Use the command fn inspect function.
To list the hello function's invoke endpoint we can type:

------------------------------
$ fn inspect f hello-app hello
------------------------------

Get the value from the annotation fnproject.io/fn/invokeEndpoint in the result of this inspect command.

You can invoke the function using curl at this endpoint. 
Please set an environment variable HELLO_FUNCTION_ENDPOINT with the value from the endpoint.

-----------------------------------------------------
$ export HELLO_FUNCTION_ENDPOINT=<theInvokeEndpoint>
-----------------------------------------------------

For example: export HELLO_FUNCTION_ENDPOINT=http://localhost:8080/invoke/01DY4P5ZSFNG9000GZJ0000002.

Now with the variable set you should be able to invoke the function using curl:

-------------------------------------------------------------------------------------------------
$ curl -X "POST" -H "Content-Type: application/json" -d '{"name":"Bob"}' $HELLO_FUNCTION_ENDPOINT
-------------------------------------------------------------------------------------------------

Context available to a Function when processing a Request.
==========================================================

When you invoke a function, the request is handled and forwarded by the Fn Server to the function. 
This means that an HTTP request is sent to the container that implements the function. 
This request is received by a handler provided by the Fn FDK for Node. 
This handler can be seen in the file func.js - which is the generated Node implementation of the function.

Click on the file func.js to open it in the editor. 
On line 3 you see the call fdk.handle(). 
This initializes the Fn Runtime with a generic request handler; 
when a request is received it is forwarded to the function that is passed to fdk.handle() 
- the function that takes one parameter called input.

Add a second parameter to the function definition on line 3, to make this line read:

-----------------------------------
> fdk.handle(function(input , ctx){
-----------------------------------

The FDK framework's handler (fdk.handle) will now pass the request context in this variable, 
in addition to the input or payload that was already passed to the function by the handler.

Change line 8 to make it read:

------------------------------------------------
> return {'message': 'Hello ' + name ,'ctx':ctx}
------------------------------------------------

Changes to file func.js are saved automatically by the editor - do not look for a Save button or use Ctrl+S.

Now we need to redeploy the function with the same command as before:

--------------------------------------
$ fn -v deploy --app hello-app --local
--------------------------------------

And invoke it, either through Fn:

------------------------------------------------------------------------------------------------
$ echo -n '{"name":"Your Own Name"}' | fn invoke hello-app hello --content-type application/json
------------------------------------------------------------------------------------------------

Or using CURL.

-----------------------------------------------------------------------------------------------------------------------
$ curl -X "POST" -H "Content-Type: application/json" -H "new-header: val" -d '{"name":"Tom"}' $HELLO_FUNCTION_ENDPOINT
-----------------------------------------------------------------------------------------------------------------------

The custom header should now be visible in the response from the function 
because it is visible in the context sent to the function by Fn.

By inspecting the ctx input parameter, you can make your function interpret the request in a more encompassing way 
than by only inspecting the input parameter. 

Detailed Overview of the Function Context
=========================================

Context Variable (CTX)

  ctx.config : An Object containing function config variables (from the environment ) (read only)
  ctx.headers : an object containing input headers for the event as lists of strings (read only)
  ctx.deadline : a Date object indicating when the function call must be processed by
  ctx.callID : The call ID of the current call
  ctx.fnID : The Function ID of the current function
  ctx.memory : Amount of ram in MB allocated to this function
  ctx.contentType : The incoming request content type (if set, otherwise null)
  ctx.setResponseHeader(key,values...) : Sets a response header to one or more values
  ctx.addResponseHeader(key,values...) : Appends values to an existing response header
  ctx.responseContentType set/read the response content type of the function (read/write)
  ctx.httpGateway The HTTP Gateway context for this function (if set)

Creating Functions in other Languages
=====================================

The hello function we have been working with in the previous steps was implemented using Node JS.
Fn supports many other runtime, such as Go, Python, Java and Ruby.
Additionally, you can create a function from just any Docker Container,
regardless which (combination of) runtime engines and languages you have used in it.

In this step you will create a function in Java. Feel free to try out the other runtimes as well.

Return to the home directory and create a new function called hello-java with Java as its runtime engine.
-----------------------------------
$ cd ~
$ fn init --runtime java hello-java
-----------------------------------
Check out the generated directory structure and Java Classes:

-------
$ ls -R
-------

Now inspect the generated Java class that handles requests - and can be customized by us.

--------------------------------------------
$ cd hello-java/src/main/java/com/example/fn
$ cat HelloFunction.java
--------------------------------------------

Java Class HelloFunction.java was generated as the starting point for this function.
You can check out file in the editor.

Warning: if you make changes to the output of the file, ensure that you change the unit test accordingly
because when the test fails, the function cannot be built and deployed.
The unit test is in the source file hello-java/src/test/java/com/example/fn/HelloFunctionTest.java.

It is not as obvious as in the func.js generated for the Node runtime that an Fn handler is at play.
However, also in the case of Java based functions, requests are handled by a generic Fn Java runtime handler
before being passed to our own code. 
Check in func.yaml how the Java Class and method that the generic handler should forward the request to are specified.

Deploy the Java Function hello-java locally, into the app that was created in step 2 of this scenario.
You will again see a Docker Container Image being built. Or actually: two images.
The first image is the build environment with the full Java JDK, Maven and facilities to run unit tests.
The outcome of this first image is a Fat Jar that contains the built application artifact.
This is the input for the second container image 
- that is based on the Java Runtime Environment, a much lighter weight image. 
The final result of deploying the function is the image based on JRE and with only the Fat Jar created for the function

--------------------------------------
$ cd ~/hello-java
$ fn -v deploy --app hello-app --local
--------------------------------------

To invoke the Java function, execute this command:

--------------------------------
$ fn invoke hello-app hello-java
--------------------------------

To send input to the function, use the following command:

------------------------------------------------------------------------------------------
$ echo -n 'Your Own Name' | fn invoke hello-app hello-java --content-type application/json
------------------------------------------------------------------------------------------

Again, a friendly, this time personalized, welcome message should be your reward.

Further Explorations
====================

To try out other languages, simply replace java as runtime with go or python.

GraalVM
=======

Project Fn also supports binary executables with GraalVM;
there is a special runtime available that takes a Java application and builds it all the way into a container image 
with just a binary executable. This results in an even smaller image and even faster function warmup and execution.
Read this article for details:
https://medium.com/fnproject/serverless-functions-some-like-it-aot-ea8b46951335

APENDIX:

https://technology.amis.nl/2020/01/02/oracle-cloud-infrastructure-functions-and-project-fn-retrieving-headers-query-parameters-and-other-http-request-elements/


